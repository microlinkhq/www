---
description: Guidelines for styled-components and styling patterns
alwaysApply: false
---

# Styling Conventions

This project uses `styled-components` with `styled-system` for theming. Follow these patterns for consistency.

## Styled Components

### 1. Use Theme Values

Always reference theme values instead of hardcoding:

```javascript
// Good
import { colors, space, transition } from 'theme'

const StyledButton = styled(Box)`
  transition: background-color ${transition.medium};
  padding: ${space[3]};
  background: ${colors.link};
`

// Avoid
const StyledButton = styled(Box)`
  transition: background-color 0.3s;
  padding: 16px;
  background: #3B82F6;
`
```

### 2. Extend Base Components

Build on existing base components (Box, Flex, Text) rather than creating from scratch:

```javascript
import Box from '../Box'

const StyledButton = styled(Box)`
  // Additional styles
`
```

### 3. Use the `theme` Helper for Styled-System Props

For styled-system properties, use the `theme` helper:

```javascript
import { theme } from 'theme'

<Flex css={theme({
  pl: `calc(${ASIDE_WIDTH} + 14px)`,
  flexDirection: 'column'
})} />
```

### 4. Conditional Styles with Props

Use props for conditional styling:

```javascript
const StyledButton = styled(Box)`
  ${({ variant }) =>
    variant === 'gradient' &&
    `
    background: ${gradient};
    padding: ${space[1]};
  `}

  ${({ theme, variant }) => {
    const { background, color } = getVariant({ theme, variant })
    return themeProp({
      background,
      color,
      _hover: hoverStyle({ theme, variant })
    })
  }}
`
```

### 5. Extract Style Logic

Extract complex style calculations into separate functions:

```javascript
const getVariant = ({ theme, variant }) => {
  const { background = 'link', color = 'white' } =
    theme.variants.buttons[variant] || {}
  return { background, color }
}

export const hoverStyle = ({ theme, variant }) => {
  const { background, color } = getVariant({ theme, variant })
  return {
    cursor: 'pointer',
    background: color,
    color: background,
    boxShadow: `0 0 0 1px ${colors[background]}`
  }
}
```

### 6. Use `withConfig` for shouldForwardProp

Prevent styled-system from forwarding custom props to the DOM:

```javascript
const StyledButton = styled(Box).withConfig({
  shouldForwardProp: prop => !['variant'].includes(prop)
})`
  // styles
`
```

### 7. Pseudo-Selectors with Styled-System

Use underscore-prefixed props for pseudo-selectors:

```javascript
themeProp({
  color: 'white',
  background: 'black',
  _hover: {
    color: 'black',
    background: 'white'
  },
  _disabled: {
    opacity: 0.8,
    cursor: 'not-allowed'
  }
})
```

### 8. CSS Prop for One-Off Styles

Use the `css` prop for component-specific styles. For markdown components, centering is often conditional based on `isBlogPage`:

```javascript
<Box css={theme({
  maxWidth: layout.small,
  mx: isBlogPage ? 'auto' : undefined
})}>
  {children}
</Box>
```

### 9. Inline CSS Template Strings

For complex one-off styles, use template literals:

```javascript
const css = `
  box-shadow: ${shadows[0]};
  background: white;
  z-index: 3;
`

<AsideBase css={css} />
```

## Common Patterns

### Transitions

Always use theme transition values:

```javascript
transition: background-color ${transition.medium},
            color ${transition.medium},
            box-shadow ${transition.medium};
```

Available: `transition.short`, `transition.medium`, `transition.long`

### Shadows

Use theme shadow values:

```javascript
box-shadow: ${shadows[0]};
```

### Responsive Styles

**Always use array syntax for responsive values instead of breakpoint checks.**

The array index corresponds to the breakpoint:
- Index 0: Mobile (< 600px)
- Index 1: Tablet (600px - 767px)
- Index 2: Desktop (768px - 1199px)
- Index 3: Large Desktop (≥ 1200px)

```javascript
// ✅ Good - Use arrays for responsive values
css={theme({
  px: [2, 0],  // 2 on mobile, 0 on tablet+ (no need to repeat 0)
  maxWidth: ['100%', layout.small],  // 100% on mobile, layout.small on tablet+ (no need to repeat)
  fontSize: [1, 2, 3],  // Mobile, tablet, desktop
  height: ['200px', '325px']  // 200px on mobile, 325px on tablet+ (no need to repeat)
})}

// ❌ Bad - Don't repeat constant values
css={theme({
  px: [2, 0, 0, 0],  // Unnecessary repetition
  maxWidth: ['100%', layout.small, layout.small, layout.small]  // Unnecessary repetition
})}

// ❌ Bad - Don't use breakpoint checks
const breakpoint = useBreakpoint()
css={theme({
  px: breakpoint === 0 ? 2 : 0,
  maxWidth: breakpoint === 0 ? '100%' : layout.small
})}
```

**Note:** If a value is constant for all subsequent breakpoints, you don't need to repeat it. The last value in the array applies to all remaining breakpoints.

**Never import or use `useBreakpoint` hook for styling.** The theme system handles responsive values automatically through array syntax.

### Colors

Always use theme colors:

```javascript
import { colors } from 'theme'

color: ${colors.black50}
background: ${colors.white}
border: 1px solid ${colors.black20}
```

## SCSS

For global styles, use SCSS in [src/styles/main.scss](mdc:src/styles/main.scss):

- Component-specific styles should use styled-components
- Global resets, typography, and base styles go in SCSS
- Import normalize.css for consistent base styles
